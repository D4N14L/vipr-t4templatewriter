<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension="\\" #>
<#
CustomT4Host host       = (CustomT4Host) Host;
OdcmModel model         = host.CurrentModel;
CodeWriterPython writer   = (CodeWriterPython) host.CodeWriter;
OdcmClass complex = (OdcmClass)host.CurrentType;
#>
<#=writer.WriteHeader()#>

<# 
    List<String> list = new List<String>();
    foreach(var property in complex.Properties){
        var propertyName = property.Name.ToUnderscore();
        if (property.Type.IsComplex() 
            && !list.Contains(property.Type.GetTypeString()) 
            && !property.Type.GetTypeString().Equals(complex.Name.ToUpperFirstChar())) {
            list.Add(property.Type.GetTypeString());
#>
from ..models.<#=property.Type.GetTypeString().ToUnderscore()#> import <#=property.Type.GetTypeString()#>
<#
        }
    }
    if (complex.Properties.Any(prop => prop.Type.GetTypeString() == "datetime")){
#>
from datetime import datetime
<#
    }
#>

class <#=complex.Name.ToUpperFirstChar()#>(object):

    def __init__(self, prop_dict={}):
        self._prop_dict = prop_dict

<# 
        foreach(var property in complex.Properties.Where(prop => prop.Type.GetTypeString() != "bytes")){
            var propertyName = property.Name.ToUnderscore();
            if (!property.Type.IsComplex()) {
#>
    @property
    def <#=propertyName#>(self):
        """
        Gets the <#=property.Name#>
        :returns: The <#=property.Name#>
        :rtype: <#=property.Type.GetTypeString()#>
        """
        if "<#=property.Name#>" in self._prop_dict:
<#
            if (property.Type.GetTypeString() == "datetime") {
#>
            return datetime.strptime(self._prop_dict["<#=property.Name#>"].replace("Z", ""), "%Y-%m-%dT%H:%M:%S.%f")
<#
            } else {
#>
            return self._prop_dict["<#=property.Name#>"]
<#
            }
#>
        else:
            return None

    @<#=propertyName#>.setter
    def <#=propertyName#>(self, val):
        """
        Sets the <#=property.Name#>
        :param val: The value to set <#=property.Name#> to
        :type val: <#=property.Type.GetTypeString()#>
        """
        if not isinstance(val, <#=property.Type.GetTypeString()#>) and val is not None:
            raise TypeError(
                'Type provided is not of type ' + <#=property.Type.GetTypeString()#>.__name__)
<#
            if (property.Type.GetTypeString() == "datetime") {
#>
        self._prop_dict["<#=property.Name#>"] = val.isoformat()+"Z"

<#
            } else {
#>
        self._prop_dict["<#=property.Name#>"] = val

<#
            }
        } else {
#>
    @property
    def <#=propertyName#>(self):
        """
        Gets the <#=property.Name#>
        :returns: The <#=property.Name#>
        :rtype: <#=property.Type.GetTypeString()#>
        """
        if "<#=property.Name#>" in self._prop_dict:
            return <#=property.Type.GetTypeString()#>(self._prop_dict["<#=property.Name#>"])
        else:
            return None

    @<#=propertyName#>.setter
    def <#=propertyName#>(self, val):
        """
        Sets the <#=property.Name#>
        :param val: The value to set <#=property.Name#> to
        :type val: <#=property.Type.GetTypeString()#>
        """
        if not isinstance(val, <#=property.Type.GetTypeString()#>) and val is not None:
            raise TypeError(
                'Type provided is not of type ' + <#=property.Type.GetTypeString()#>.__name__)
        self._prop_dict["<#=property.Name#>"] = val._prop_dict

<#
        }
    }
#>