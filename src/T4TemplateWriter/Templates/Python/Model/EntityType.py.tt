<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension="\\" #>
<#
CustomT4Host host       = (CustomT4Host) Host;
OdcmModel model         = host.CurrentModel;
CodeWriterPython writer = (CodeWriterPython) host.CodeWriter;
OdcmClass entity        = host.CurrentType.AsOdcmClass();
TemplateWriterSettings settings = ConfigurationService.Settings;

#>
<#=writer.WriteHeader()#>

<# 
    List<String> list = new List<String>();
    foreach(var property in entity.Properties){
        var propertyName = property.Name.ToUnderscore();
        if (property.Type.IsComplex() 
            && !list.Contains(property.Type.GetTypeString())
            && !property.Type.GetTypeString().Equals(entity.Name.ToUpperFirstChar())) {
            list.Add(property.Type.GetTypeString());
#>
from ..Models.<#=property.Type.GetTypeString().ToUnderscore()#> import <#=property.Type.GetTypeString()#>
<#
        }
    }
#>

class <#=entity.Name.ToUpperFirstChar()#>(object):

    def __init__(self, prop_dict={}):
        self._prop_dict = prop_dict

<# 
        foreach(var property in entity.Properties){
            var propertyName = property.Name.ToUnderscore();
            var propertyNameCap = property.Name.ToUpperFirstChar();
            if (property.Type.IsComplex()) {
                if (property.IsCollection()) {
#>
    @property
    def <#=propertyName#>(self):
        """Gets <#=property.Name#> """
        if "<#=property.Name#>" in self._prop_dict:
            return <#=propertyNameCap#>CollectionPage(self._prop_dict["<#=property.Name#>"])
        else:
            return None

    @<#=propertyName#>.setter
    def <#=propertyName#>(self, val):
        """Sets <#=property.Name#> """
        if not isinstance(val, <#=propertyNameCap#>CollectionPage) and val is not None:
            raise TypeError(
                'Type provided is not of type ' + <#=propertyNameCap#>CollectionPage.__name__)
        self._prop_dict["<#=property.Name#>"] = val._prop_dict

<#
            } else {
#>
    @property
    def <#=propertyName#>(self):
        """Gets <#=property.Name#> """
        if "<#=property.Name#>" in self._prop_dict:
            return <#=property.Type.GetTypeString()#>(self._prop_dict["<#=property.Name#>"])
        else:
            return None

    @<#=propertyName#>.setter
    def <#=propertyName#>(self, val):
        """Sets <#=property.Name#> """
        if not isinstance(val, <#=property.Type.GetTypeString()#>) and val is not None:
            raise TypeError(
                'Type provided is not of type ' + <#=property.Type.GetTypeString()#>.__name__)
        self._prop_dict["<#=property.Name#>"] = val._prop_dict

<#
            }
        } else {
#>
    @property
    def <#=propertyName#>(self):
        """Gets <#=property.Name#> """
        if "<#=property.Name#>" in self._prop_dict:
            return self._prop_dict["<#=property.Name#>"]
        else:
            return None

    @<#=propertyName#>.setter
    def <#=propertyName#>(self, val):
        """Sets <#=property.Name#> """
        if not isinstance(val, <#=property.Type.GetTypeString()#>) and val is not None:
            raise TypeError(
                'Type provided is not of type ' + <#=property.Type.GetTypeString()#>.__name__)
        self._prop_dict["<#=property.Name#>"] = val

<#
        }
    }
#>
    @property
    def additional_data(self):
        """Gets additional data dictionary"""
        return self._prop_dict
