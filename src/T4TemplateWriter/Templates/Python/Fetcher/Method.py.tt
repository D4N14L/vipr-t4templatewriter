<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension="\\" #>
<#
CustomT4Host host       = (CustomT4Host) Host;
OdcmModel model         = host.CurrentModel;
CodeWriterPython writer = (CodeWriterPython) host.CodeWriter;
var clientName          = model.GetEntityContainer().ToUpperFirstChar() + "Client";
var clientNameLower     = clientName.ToLowerFirstChar();
var method              = host.CurrentType as OdcmMethod;
var entityName          = method.Class.Name.ToUpperFirstChar();
var httpMethod          = method.IsAction ? "POST" : "GET";
var requestType         = entityName + method.Name.Substring(method.Name.IndexOf('.') + 1).ToUpperFirstChar() + "Request";
var requestBuilderType  = requestType + "Builder";
var returnType          = method.ReturnType.Name.ToUpperFirstChar();
var returnTypeCollection= "ItemsCollectionResponse";
bool hasParameters      = method.Parameters != null && method.Parameters.Any();
TemplateWriterSettings settings = ConfigurationService.Settings;

#>
<#=writer.WriteHeader()#>

from ..Models.<#=returnType.ToUnderscore()#> import <#=returnType#>
<#=method.IsCollection ? "from ..collection_base import CollectionRequestBase" : "from ..request_base import RequestBase"#>
<#
if (method.IsCollection) {
#>
from ..Requests.items_collection import ItemsCollectionResponse
<#
}
#>
from ..request_builder_base import RequestBuilderBase
<#
if (method.IsMethodAsync()){
#>
from ..async_operation import AsyncOperation
<#
}
#>
from ..options import *
import asyncio
import json

class <#=requestType#>(<#=method.IsCollection ? "CollectionRequestBase" : "RequestBase"#>):
<#
    var paramStringBuilder = new System.Text.StringBuilder();
    var requestBodyInitializerBuilder = new System.Text.StringBuilder();
    paramStringBuilder.Append("self, request_url, client, options");

    foreach (var param in method.Parameters.Where(p => !p.IsNullable)){
        paramStringBuilder.Append(", " + param.Name.ToUnderscore());
        requestBodyInitializerBuilder.Append("        ");
        requestBodyInitializerBuilder.Append(method.IsAction ? "self.body_options" : "self._query_options");
        requestBodyInitializerBuilder.Append("[\""+param.Name+"\"]");
        requestBodyInitializerBuilder.Append(" = "+param.Name.ToUnderscore());
        requestBodyInitializerBuilder.Append(Environment.NewLine);
    }
    foreach (var param in method.Parameters.Where(p => p.IsNullable)){
        paramStringBuilder.Append(", " + param.Name.ToUnderscore() + "=None");
        requestBodyInitializerBuilder.Append("        ");
        requestBodyInitializerBuilder.Append(method.IsAction ? "self.body_options" : "self._query_options");
        requestBodyInitializerBuilder.Append("[\""+param.Name+"\"]");
        requestBodyInitializerBuilder.Append(" = "+param.Name.ToUnderscore());
        requestBodyInitializerBuilder.Append(Environment.NewLine);
    }

#>
    def __init__(<#=paramStringBuilder.ToString()#>):
        super(<#=requestType#>, self).__init__(request_url, client, options)
        self.method = "<#=httpMethod#>"
<#
        if (method.IsAction) {
#>
        self.body_options={}
<#
    }
    if (hasParameters) {
#>
<#=requestBodyInitializerBuilder.ToString()#>
<#
    }
    if (method.IsAction) {
#>
    @property
    def body_options(self):
        return self._body_options
    
    @body_options.setter
    def body_options(self, value):
        self._body_options=value
<#
    }
    if (hasParameters && method.IsAction){
#>

    def <#=httpMethod.ToLower()#>(self):
        """
        Sends the <#=httpMethod.ToUpper()#> request
        :returns: The resulting <#=method.IsCollection ? "collection" : "entity"#> from the operation 
        :rtype: <#if (method.IsMethodAsync()){#>AsyncOperation<#} else {#><#=method.IsCollection ? returnTypeCollection : returnType#><#}#>
        """
        self.content_type = "application/json"
<#
        if (method.IsMethodAsync()){
#>
        self.append_option(HeaderOption("Prefer", "respond-async"))
        entity_response = self.send(self.body_options)
        entity = AsyncOperation(entity_response.headers["Location"], self._client, None)
<#
        } else {
#>
        entity = <#=method.IsCollection ? returnTypeCollection : returnType#>(json.loads(self.send(self.body_options).content))
<#
        }
#>
        return entity

    @asyncio.coroutine
    def <#=httpMethod.ToLower()#>_async(self):
        """
        Sends the <#=httpMethod.ToUpper()#> request using an asyncio coroutine
        :returns: The resulting <#=method.IsCollection ? "collection" : "entity"#> from the operation 
        :rtype: <#if (method.IsMethodAsync()){#>AsyncOperation<#} else {#><#=method.IsCollection ? returnTypeCollection : returnType#><#}#>
        """
<#
        if (method.IsMethodAsync()){
#>
        self.append_option(HeaderOption("Prefer", "respond-async"))
<#
        }
#>
        self.content_type = "application/json"
        entity_response = yield from self.send_async(self.body_options)
<#
        if (method.IsMethodAsync()){
#>
        entity = AsyncOperation(entity_response.headers["Location"], self._client, None)
<#
        } else {
#>
        entity = <#=method.IsCollection ? returnTypeCollection : returnType#>(json.loads(entity_response.content))
<#
        }
#>
        return entity
<#
    } else {
#>

    def <#=httpMethod.ToLower()#>(self):
        """
        Sends the <#=httpMethod.ToUpper()#> request
        :returns: The resulting <#=method.IsCollection ? "collection response" : "entity"#> from the operation 
<#
        if (method.IsMethodAsync()){
#>
        :rtype: AsyncOperation       
<#
        } else {
#>
        :rtype: <#=method.IsCollection ? returnTypeCollection : returnType#>
<#
        }
#>
        """
<#
        if (method.IsMethodAsync()){
#>
        self.headers["Prefer"] = "respond-async"
        entity_response = self.send()
        entity = AsyncOperation(entity_response.headers["Location"], self._client, None)
<#
        } else {
#>
        entity = <#=method.IsCollection ? returnTypeCollection : returnType#>(json.loads(self.send().content))
<#
        }
#>
        return entity

    @asyncio.coroutine
    def <#=httpMethod.ToLower()#>_async(self):
        """
        Sends the <#=httpMethod.ToUpper()#> request using an asyncio coroutine
        :returns: The resulting <#=method.IsCollection ? "collection response" : "entity"#> from the operation 
<#
        if (method.IsMethodAsync()){
#>
        :rtype: AsyncOperation       
<#
        } else {
#>
        :rtype: <#=method.IsCollection ? returnTypeCollection : returnType#>
<#
        }
#>
        """
<#
        if (method.IsMethodAsync()){
#>
        self.headers["Prefer"] = "respond-async"
<#
        }
#>
        entity_response = yield from self.send_async()
<#
        if (method.IsMethodAsync()){
#>
        entity = AsyncOperation(entity_response.headers["Location"], self._client, None)
<#
        } else {
#>
        entity = <#=method.IsCollection ? returnTypeCollection : returnType#>(json.loads(entity_response.content))
<#
        }
#>
        return entity
<#
    }
#>

class <#=requestBuilderType#>(RequestBuilderBase):
<#
    paramStringBuilder = new System.Text.StringBuilder();
    var requestBuilderInitializerBuilder = new System.Text.StringBuilder();
    var requestConstructorBuilder = new System.Text.StringBuilder();

    requestConstructorBuilder.Append("self._request_url, self._client, options");
    paramStringBuilder.Append("self, request_url, client");

    foreach (var param in method.Parameters.Where(p => !p.IsNullable)){
        requestConstructorBuilder.Append(", self._method_options[\""+param.Name+"\"]");
        paramStringBuilder.Append(", " + param.Name.ToUnderscore());
        requestBuilderInitializerBuilder.Append(Environment.NewLine);
        requestBuilderInitializerBuilder.Append("        ");
        requestBuilderInitializerBuilder.Append("self._method_options");
        requestBuilderInitializerBuilder.Append("[\""+param.Name+"\"]");
        requestBuilderInitializerBuilder.Append(" = "+param.Name.ToUnderscore());
        if (param.Type.IsComplex())
            requestBuilderInitializerBuilder.Append("._prop_dict");
    }
    foreach (var param in method.Parameters.Where(p => p.IsNullable)){
        requestConstructorBuilder.Append(", "+param.Name.ToUnderscore()+"=self._method_options[\""+param.Name+"\"]");
        paramStringBuilder.Append(", " + param.Name.ToUnderscore() + "=None");
        requestBuilderInitializerBuilder.Append(Environment.NewLine);
        requestBuilderInitializerBuilder.Append("        ");
        requestBuilderInitializerBuilder.Append("self._method_options");
        requestBuilderInitializerBuilder.Append("[\""+param.Name+"\"]");
        requestBuilderInitializerBuilder.Append(" = "+param.Name.ToUnderscore());
        if (param.Type.IsComplex())
            requestBuilderInitializerBuilder.Append("._prop_dict");
    }

#>

    def __init__(<#=paramStringBuilder.ToString()#>):
        super(<#=requestBuilderType#>, self).__init__(request_url, client)
<#
    if (hasParameters) {
#>
        self._method_options = {}
<#=requestBuilderInitializerBuilder.ToString()#>
<#
    }
#>

    def request(self, options=None):
        """
        Builds the request for the <#=requestType.Replace("Request","")#>
        :param options: List of options to include in the request
        :type options: List of type Options
        :returns: The request
        :rtype: <#=requestType#>
        """
        return <#=requestType#>(<#=requestConstructorBuilder#>)
